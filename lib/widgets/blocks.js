"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateContextVarExpr = exports.duplicateBlockDef = exports.createExprVariableValues = exports.createExprVariables = exports.getBlockTree = exports.findBlockAncestry = exports.dropBlock = exports.Block = exports.NullBlockStore = exports.DropSide = void 0;
var lodash_1 = __importDefault(require("lodash"));
var uuid_1 = require("uuid");
var mwater_expressions_1 = require("mwater-expressions");
require("./blocks.css");
/** Side on which another block is dropped on a block */
var DropSide;
(function (DropSide) {
    DropSide["top"] = "Top";
    DropSide["bottom"] = "Bottom";
    DropSide["left"] = "Left";
    DropSide["right"] = "Right";
})(DropSide = exports.DropSide || (exports.DropSide = {}));
/** Store which throws on any operation */
var NullBlockStore = /** @class */ (function () {
    function NullBlockStore() {
    }
    NullBlockStore.prototype.alterBlock = function (blockId, action) {
        throw new Error("Not allowed");
    };
    NullBlockStore.prototype.replaceBlock = function (blockDef) {
        throw new Error("Not allowed");
    };
    return NullBlockStore;
}());
exports.NullBlockStore = NullBlockStore;
/** Block class. Ephemeral class that is created for a block def and
 * contains the logic and display for a block type.
 * Note: Designer (renderDesign and renderEditor) can assume that the block def is canonical.
 * Instance, however, cannot assume that.
 */
var Block = /** @class */ (function () {
    function Block(blockDef) {
        this.blockDef = blockDef;
    }
    Object.defineProperty(Block.prototype, "id", {
        get: function () { return this.blockDef.id; },
        enumerable: false,
        configurable: true
    });
    /** Render an optional property editor for the block. This may use bootstrap */
    Block.prototype.renderEditor = function (designCtx) { return null; };
    /** Get any context variables expressions that this block needs (not including child blocks) */
    Block.prototype.getContextVarExprs = function (contextVar, ctx) { return []; };
    /** Get any context variables expressions that this block needs *including* child blocks. Can be overridden */
    Block.prototype.getSubtreeContextVarExprs = function (contextVar, ctx) {
        // Get own exprs
        var ownExprs = this.getContextVarExprs(contextVar, ctx);
        // Append child ones
        for (var _i = 0, _a = this.getChildren(ctx.contextVars); _i < _a.length; _i++) {
            var childBlock = _a[_i];
            var block = ctx.createBlock(childBlock.blockDef);
            ownExprs = ownExprs.concat(block.getSubtreeContextVarExprs(contextVar, ctx));
        }
        return ownExprs;
    };
    /**
     * Processes entire tree, starting at bottom. Allows
     * easy mutation of the tree
     */
    Block.prototype.process = function (createBlock, action) {
        var blockDef = this.processChildren(function (childBlockDef) {
            // Recursively process, starting at bottom
            if (childBlockDef != null) {
                return createBlock(childBlockDef).process(createBlock, action);
            }
            else {
                return null;
            }
        });
        return action(blockDef);
    };
    /** Get initial filters generated by this block. Does not include child blocks */
    Block.prototype.getInitialFilters = function (contextVarId, instanceCtx) { return []; };
    /** Get initial filters generated by this block and any children */
    Block.prototype.getSubtreeInitialFilters = function (contextVarId, instanceCtx) {
        // Get own filters
        var ownFilters = this.getInitialFilters(contextVarId, instanceCtx);
        // Append child ones
        for (var _i = 0, _a = this.getChildren(instanceCtx.contextVars); _i < _a.length; _i++) {
            var childBlock = _a[_i];
            var block = instanceCtx.createBlock(childBlock.blockDef);
            ownFilters = ownFilters.concat(block.getSubtreeInitialFilters(contextVarId, instanceCtx));
        }
        return ownFilters;
    };
    /** Canonicalize the block definition. Should be done after operations on the block are completed. Only alter self, not children.
     * Can also be used to upgrade blocks
     */
    Block.prototype.canonicalize = function () {
        return this.blockDef;
    };
    /** Get label to display in designer */
    Block.prototype.getLabel = function () {
        return this.blockDef.type;
    };
    return Block;
}());
exports.Block = Block;
// Handles logic of a simple dropping of a block on another
function dropBlock(droppedBlockDef, targetBlockDef, dropSide) {
    if (dropSide === DropSide.left) {
        return {
            id: uuid_1.v4(),
            items: [droppedBlockDef, targetBlockDef],
            type: "horizontal"
        };
    }
    if (dropSide === DropSide.right) {
        return {
            id: uuid_1.v4(),
            items: [targetBlockDef, droppedBlockDef],
            type: "horizontal"
        };
    }
    if (dropSide === DropSide.top) {
        return {
            id: uuid_1.v4(),
            items: [droppedBlockDef, targetBlockDef],
            type: "vertical"
        };
    }
    if (dropSide === DropSide.bottom) {
        return {
            id: uuid_1.v4(),
            items: [targetBlockDef, droppedBlockDef],
            type: "vertical"
        };
    }
    throw new Error("Unknown side");
}
exports.dropBlock = dropBlock;
/**
 * Find the entire ancestry (root first) of a block with the specified id
 *
 * @param rootBlockDef root block to search in
 * @param createBlock
 * @param blockId block to find
 * @returns array of child blocks, each with information about which context variables were injected by their parent
 */
function findBlockAncestry(rootBlockDef, createBlock, contextVars, blockId) {
    var rootBlock = createBlock(rootBlockDef);
    // Return self if true
    if (rootBlock.id === blockId) {
        return [{ blockDef: rootBlockDef, contextVars: contextVars }];
    }
    // For each child
    for (var _i = 0, _a = rootBlock.getChildren(contextVars); _i < _a.length; _i++) {
        var childBlock = _a[_i];
        if (childBlock.blockDef) {
            var childAncestry = findBlockAncestry(childBlock.blockDef, createBlock, childBlock.contextVars, blockId);
            if (childAncestry) {
                return [{ blockDef: rootBlockDef, contextVars: contextVars }].concat(childAncestry);
            }
        }
    }
    return null;
}
exports.findBlockAncestry = findBlockAncestry;
/** Get the entire tree of blocks from a root, including context variables for each */
function getBlockTree(rootBlockDef, createBlock, contextVars) {
    var rootChildBlock = { blockDef: rootBlockDef, contextVars: contextVars };
    // Create list including children
    var list = [rootChildBlock];
    // For each child
    for (var _i = 0, _a = createBlock(rootBlockDef).getChildren(contextVars); _i < _a.length; _i++) {
        var childBlock = _a[_i];
        if (childBlock.blockDef) {
            var childTree = getBlockTree(childBlock.blockDef, createBlock, childBlock.contextVars);
            list = list.concat(childTree);
        }
    }
    return list;
}
exports.getBlockTree = getBlockTree;
/** Create the variables as needed by mwater-expressions */
function createExprVariables(contextVar) {
    return contextVar.map(function (cv) {
        switch (cv.type) {
            case "row":
                return { id: cv.id, type: "id", name: { _base: "en", en: cv.name }, idTable: cv.table };
            case "rowset":
                return { id: cv.id, type: "boolean", name: { _base: "en", en: cv.name }, table: cv.table };
            case "id":
                return { id: cv.id, type: "id", name: { _base: "en", en: cv.name }, idTable: cv.table };
            case "id[]":
                return { id: cv.id, type: "id[]", name: { _base: "en", en: cv.name }, idTable: cv.table };
        }
        return { id: cv.id, type: cv.type, name: { _base: "en", en: cv.name }, enumValues: cv.enumValues };
    });
}
exports.createExprVariables = createExprVariables;
/** Create the variable values as needed by mwater-expressions */
function createExprVariableValues(contextVars, contextVarValues) {
    return lodash_1.default.mapValues(contextVarValues, function (value, contextVarId) {
        var cv = contextVars.find(function (cv) { return cv.id == contextVarId; });
        // TODO: For some reason, there can be values with no corresponding context var. Warn for now to unbreak.
        if (!cv) {
            console.warn("createExprVariableValues: Context variable " + contextVarId + " not found");
            return null;
        }
        if (cv.type == "row") {
            return { type: "literal", valueType: "id", idTable: cv.table, value: value };
        }
        return value;
    });
}
exports.createExprVariableValues = createExprVariableValues;
/** Make a duplicate of a block */
function duplicateBlockDef(blockDef, createBlock) {
    return createBlock(blockDef).process(createBlock, function (bd) { return bd ? (__assign(__assign({}, bd), { id: uuid_1.v4() })) : null; });
}
exports.duplicateBlockDef = duplicateBlockDef;
/** Validates a context variable/expr combo. Null if ok */
function validateContextVarExpr(options) {
    var error;
    // Validate cv
    var contextVar;
    if (options.contextVarId) {
        contextVar = options.contextVars.find(function (cv) { return cv.id === options.contextVarId && (cv.type === "rowset" || cv.type === "row"); });
        if (!contextVar) {
            return "Context variable not found";
        }
    }
    // Only include context variables before up to an including one referenced, or all context variables if null
    // This is because an outer context var expr cannot reference an inner context variable
    var cvIndex = options.contextVars.findIndex(function (cv) { return cv.id === options.contextVarId; });
    var availContextVars = cvIndex >= 0 ? lodash_1.default.take(options.contextVars, cvIndex + 1) : options.contextVars;
    var exprValidator = new mwater_expressions_1.ExprValidator(options.schema, createExprVariables(availContextVars));
    // Validate expr
    error = exprValidator.validateExpr(options.expr, {
        table: contextVar ? contextVar.table : undefined,
        types: options.types,
        aggrStatuses: options.aggrStatuses,
        idTable: options.idTable,
        enumValueIds: options.enumValueIds
    });
    if (error) {
        return error;
    }
    return null;
}
exports.validateContextVarExpr = validateContextVarExpr;
