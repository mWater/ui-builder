"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateContextVarExpr = exports.duplicateBlockDef = exports.createExprVariableValues = exports.createExprVariables = exports.getBlockTree = exports.findBlockAncestry = exports.dropBlock = exports.Block = exports.NullBlockStore = exports.DropSide = void 0;
const lodash_1 = __importDefault(require("lodash"));
const uuid_1 = require("uuid");
const mwater_expressions_1 = require("mwater-expressions");
require("./blocks.css");
/** Side on which another block is dropped on a block */
var DropSide;
(function (DropSide) {
    DropSide["top"] = "Top";
    DropSide["bottom"] = "Bottom";
    DropSide["left"] = "Left";
    DropSide["right"] = "Right";
})(DropSide = exports.DropSide || (exports.DropSide = {}));
/** Store which throws on any operation */
class NullBlockStore {
    alterBlock(blockId, action) {
        throw new Error("Not allowed");
    }
    replaceBlock(blockDef) {
        throw new Error("Not allowed");
    }
}
exports.NullBlockStore = NullBlockStore;
/** Block class. Ephemeral class that is created for a block def and
 * contains the logic and display for a block type.
 * Note: Designer (renderDesign and renderEditor) can assume that the block def is canonical.
 * Instance, however, cannot assume that.
 */
class Block {
    constructor(blockDef) {
        this.blockDef = blockDef;
    }
    get id() {
        return this.blockDef.id;
    }
    /** Render an optional property editor for the block. This may use bootstrap */
    renderEditor(designCtx) {
        return null;
    }
    /** Get any context variables expressions that this block needs (not including child blocks) */
    getContextVarExprs(contextVar, ctx) {
        return [];
    }
    /** Get any context variables expressions that this block needs *including* child blocks. Can be overridden */
    getSubtreeContextVarExprs(contextVar, ctx) {
        // Get own exprs
        let ownExprs = this.getContextVarExprs(contextVar, ctx);
        // Append child ones
        for (const childBlock of this.getChildren(ctx.contextVars, ctx.schema)) {
            const block = ctx.createBlock(childBlock.blockDef);
            ownExprs = ownExprs.concat(block.getSubtreeContextVarExprs(contextVar, ctx));
        }
        return ownExprs;
    }
    /**
     * Processes entire tree, starting at bottom. Allows
     * easy mutation of the tree
     */
    process(createBlock, action) {
        const blockDef = this.processChildren((childBlockDef) => {
            // Recursively process, starting at bottom
            if (childBlockDef != null) {
                return createBlock(childBlockDef).process(createBlock, action);
            }
            else {
                return null;
            }
        });
        return action(blockDef);
    }
    /** Get initial filters generated by this block. Does not include child blocks */
    getInitialFilters(contextVarId, instanceCtx) {
        return [];
    }
    /** Get initial filters generated by this block and any children */
    getSubtreeInitialFilters(contextVarId, instanceCtx) {
        // Get own filters
        let ownFilters = this.getInitialFilters(contextVarId, instanceCtx);
        // Append child ones
        for (const childBlock of this.getChildren(instanceCtx.contextVars, instanceCtx.schema)) {
            const block = instanceCtx.createBlock(childBlock.blockDef);
            ownFilters = ownFilters.concat(block.getSubtreeInitialFilters(contextVarId, instanceCtx));
        }
        return ownFilters;
    }
    /** Canonicalize the block definition. Should be done after operations on the block are completed. Only alter self, not children.
     * Can also be used to upgrade blocks
     */
    canonicalize() {
        return this.blockDef;
    }
    /** Get label to display in designer */
    getLabel() {
        return this.blockDef.type;
    }
}
exports.Block = Block;
// Handles logic of a simple dropping of a block on another
function dropBlock(droppedBlockDef, targetBlockDef, dropSide) {
    if (dropSide === DropSide.left) {
        return {
            id: (0, uuid_1.v4)(),
            items: [droppedBlockDef, targetBlockDef],
            type: "horizontal"
        };
    }
    if (dropSide === DropSide.right) {
        return {
            id: (0, uuid_1.v4)(),
            items: [targetBlockDef, droppedBlockDef],
            type: "horizontal"
        };
    }
    if (dropSide === DropSide.top) {
        return {
            id: (0, uuid_1.v4)(),
            items: [droppedBlockDef, targetBlockDef],
            type: "vertical"
        };
    }
    if (dropSide === DropSide.bottom) {
        return {
            id: (0, uuid_1.v4)(),
            items: [targetBlockDef, droppedBlockDef],
            type: "vertical"
        };
    }
    throw new Error("Unknown side");
}
exports.dropBlock = dropBlock;
/**
 * Find the entire ancestry (root first) of a block with the specified id
 *
 * @param rootBlockDef root block to search in
 * @param createBlock
 * @param blockId block to find
 * @returns array of child blocks, each with information about which context variables were injected by their parent
 */
function findBlockAncestry(rootBlockDef, createBlock, contextVars, blockId, schema) {
    const rootBlock = createBlock(rootBlockDef);
    // Return self if true
    if (rootBlock.id === blockId) {
        return [{ blockDef: rootBlockDef, contextVars: contextVars }];
    }
    // For each child
    for (const childBlock of rootBlock.getChildren(contextVars, schema)) {
        if (childBlock.blockDef) {
            const childAncestry = findBlockAncestry(childBlock.blockDef, createBlock, childBlock.contextVars, blockId, schema);
            if (childAncestry) {
                return [{ blockDef: rootBlockDef, contextVars: contextVars }].concat(childAncestry);
            }
        }
    }
    return null;
}
exports.findBlockAncestry = findBlockAncestry;
/** Get the entire tree of blocks from a root, including context variables for each */
function getBlockTree(rootBlockDef, createBlock, contextVars, schema) {
    const rootChildBlock = { blockDef: rootBlockDef, contextVars: contextVars };
    // Create list including children
    let list = [rootChildBlock];
    // For each child
    for (const childBlock of createBlock(rootBlockDef).getChildren(contextVars, schema)) {
        if (childBlock.blockDef) {
            const childTree = getBlockTree(childBlock.blockDef, createBlock, childBlock.contextVars, schema);
            list = list.concat(childTree);
        }
    }
    return list;
}
exports.getBlockTree = getBlockTree;
/** Create the variables as needed by mwater-expressions */
function createExprVariables(contextVar) {
    return contextVar.map((cv) => {
        switch (cv.type) {
            case "row":
                return { id: cv.id, type: "id", name: { _base: "en", en: cv.name }, idTable: cv.table };
            case "rowset":
                return { id: cv.id, type: "boolean", name: { _base: "en", en: cv.name }, table: cv.table };
        }
        return {
            id: cv.id,
            type: cv.type,
            name: { _base: "en", en: cv.name },
            enumValues: cv.enumValues,
            table: cv.table,
            idTable: cv.idTable
        };
    });
}
exports.createExprVariables = createExprVariables;
/** Create the variable values as needed by mwater-expressions */
function createExprVariableValues(contextVars, contextVarValues) {
    return lodash_1.default.mapValues(contextVarValues, (value, contextVarId) => {
        const cv = contextVars.find((cv) => cv.id == contextVarId);
        // TODO: For some reason, there can be values with no corresponding context var. Warn for now to unbreak.
        if (!cv) {
            console.warn(`createExprVariableValues: Context variable ${contextVarId} not found`);
            return null;
        }
        if (cv.type == "row") {
            return { type: "literal", valueType: "id", idTable: cv.table, value: value };
        }
        return value;
    });
}
exports.createExprVariableValues = createExprVariableValues;
function escapeRegex(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
/** Make a duplicate of a block */
function duplicateBlockDef(blockDef, createBlock) {
    // Remap any changed ids
    const idMaps = [];
    let newBlockDef = createBlock(blockDef).process(createBlock, (bd) => {
        const newId = (0, uuid_1.v4)();
        idMaps.push({ from: bd.id, to: newId });
        return Object.assign(Object.assign({}, bd), { id: newId });
    });
    // Swap any referenced ids
    let json = JSON.stringify(newBlockDef);
    for (const idMap of idMaps) {
        // Don't swap empty ids or temporary ids (anything shorter than an uuid)
        if (idMap.from.length >= 32) {
            json = json.replace(new RegExp(escapeRegex(JSON.stringify(idMap.from)), "g"), JSON.stringify(idMap.to));
        }
    }
    newBlockDef = JSON.parse(json);
    return newBlockDef;
}
exports.duplicateBlockDef = duplicateBlockDef;
function validateContextVarExpr(options) {
    let error;
    const contextVarId = options.contextVarExpr ? options.contextVarExpr.contextVarId : options.contextVarId;
    const expr = options.contextVarExpr ? options.contextVarExpr.expr : options.expr;
    // Validate cv
    let contextVar = undefined;
    if (contextVarId) {
        contextVar = options.contextVars.find((cv) => cv.id === contextVarId && (cv.type === "rowset" || cv.type === "row"));
        if (!contextVar) {
            return "Context variable not found";
        }
    }
    // Only include context variables before up to an including one referenced, or all context variables if null
    // This is because an outer context var expr cannot reference an inner context variable
    const cvIndex = options.contextVars.findIndex((cv) => cv.id === contextVarId);
    const availContextVars = cvIndex >= 0 ? lodash_1.default.take(options.contextVars, cvIndex + 1) : options.contextVars;
    const exprValidator = new mwater_expressions_1.ExprValidator(options.schema, createExprVariables(availContextVars));
    // Only allow aggregate status of literal and individual for rows
    const aggrStatuses = options.aggrStatuses ||
        (contextVar && contextVar.type == "row" ? ["individual", "literal"] : ["aggregate", "individual", "literal"]);
    // Validate expr
    error = exprValidator.validateExpr(expr, {
        table: contextVar ? contextVar.table : undefined,
        types: options.types,
        aggrStatuses: aggrStatuses,
        idTable: options.idTable,
        enumValueIds: options.enumValueIds
    });
    if (error) {
        return error;
    }
    return null;
}
exports.validateContextVarExpr = validateContextVarExpr;
